
#include "Grid.cuh"
#include "VoxelsCA.cuh"
#include "BasePlate.cuh"
#include "TempField.cuh"
#include "SampleOrientation.cuh"
#include "iostream"
#include "vector"
#include <math.h>
#include <chrono>
#include <thread>
#include <algorithm>
#include "fstream"

static void HandleError(cudaError_t err) {
    if (err != cudaSuccess) {
        printf("%s \n", cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
}

int main(int argc, char *argv[])
{
  /*-----------------------------------------------
    initialization step */
  // set up all pointers for arrays in class
  // grid
  double *d_lcoor,*d_lcoor2;
  // voxels
  int *d_gID,*d_ineighID,*d_neighptr,*d_vState,nBlocks,nThreads,
  double *d_cTheta,*d_extents,*d_centroidOct;
  // tempfield
  double *d_Temp,*d_ispvec;
  // initialize class variables
  auto texec1 = std::chrono::high_resolution_clock::now();
  std::string filbaseOut,filout,filLogOut,filParamIn;
  filParamIn = argv[1];
  Grid g(filParamIn,myid,nprocs);
  Grid *d_g;
  HandleError(cudaMallocManaged((void**)&d_g,sizeof(Grid)));
  HandleError(cudaMemcpy(d_g, &g, sizeof(Grid), cudaMemcpyHostToDevice));
  HandleError(cudaMallocManaged((void**)&d_lcoor,2*g.NpT*sizeof(double)));
  HandleError(cudaMallocManaged((void**)&d_lcoor2,2*g.NpT*sizeof(double)));
  HandleError(cudaMemcpy(d_lcoor, &(g.lcoor), 2*g.NpT*sizeof(double), cudaMemcpyHostToDevice));
  HandleError(cudaMemcpy(d_lcoor2, &(g.lcoor2), 2*g.NpT*sizeof(double), cudaMemcpyHostToDevice));
  TempField TempF(g);
  TempF.InitializeAnalytic();
  TempField *d_TempF;
  HandleError(cudaMallocManaged((void**)&d_TempF,sizeof(Grid)));
  HandleError(cudaMemcpy(d_TempF, &TempF, sizeof(TempField), cudaMemcpyHostToDevice));
  std::vector<double> bpSites;
  GenerateGrainSites(g,bpSites);
  double *d_bpSites;
  HandleError(cudaMallocManaged((void**)&d_bpSites,(int)(bpSites.size())*sizeof(double)));
  VoxelsCA vox(g,TempF, part);
  vox.nGrain = bpSites.size()/3;
  VoxelsCA *d_vox;
  HandleError(cudaMallocManaged((void**)&d_vox,sizeof(VoxelsCA)));
  HandleError(cudaMemcpy(d_vox, &vox, sizeof(VoxelsCA), cudaMemcpyHostToDevice));
  nThreads=1024;
  nBlocks=(g.nX[0]*g.nX[1]*g.Nzhg)/nThreads;
  CreateBasePlateOrientations<<<nBlocks,nThreads>>>(d_g,d_bpSites);
  HandleError(cudaMallocManaged((void**)&d_gID,Ntot*sizeof(int)));
  HandleError(cudaMallocManaged((void**)&d_vState,Ntot*sizeof(int)));
  HandleError(cudaMallocManaged((void**)&d_extents,Ntot*sizeof(double)));
  HandleError(cudaMallocManaged((void**)&d_centroidOct,3*Ntot*sizeof(double)));
  HandleError(cudaMemset(d_gID,Ntot*sizeof(int)));
  HandleError(cudaMemset(d_vState,Ntot*sizeof(int)));
  HandleError(cudaMemset(d_extents,Ntot*sizeof(double)));
  HandleError(cudaMemset(d_centroidOct,3*Ntot*sizeof(double)));
  HandleError(cudaMallocManaged((void**)&d_cTheta,4*vox.nGrain*sizeof(double)));
  int Ntot=g.nX[0]*g.nX[1]*g.nX[2];
  nBlocks=Ntot/nThreads;
  CreateBasePlateGrains<<<nBlocks,nThreads>>>(d_vox,d_bp,d_gID,d_vState,d_g,d_bpSites,d_extends, &
					    d_centroidOct,Ntot);
  nBlocks=vox.nGrain/nThreads;
  CreateBasePlateOrientations<<<nBlocks,nThreads>>>(d_vox,d_cTheta);
  



  /*-----------------------------------------------
    execute simulation */
  int indOut,nFils;
  double filSize=(g.nX[0]/1e2*g.nX[1]/1e2*g.nX[2]/1e2*4*(9+3+3+8)+12)/1e3;
  nFils = int(ceil(filSize/1.5 ));
  std::vector<int> filinds,out2(2,0);
  std::vector<double> filtime;
  int nlayerTot,icheck = 1,ichecktmp;
  std::ofstream fplog;
  bool bcheck=0;
  filbaseOut = "CA3D"+filParamIn.substr(0,filParamIn.find("."));
  filLogOut="CA3D"+filParamIn.substr(0,filParamIn.find("."))+".log";
  if (part.myid==0){
    fplog.open(filLogOut.c_str());
    fplog << "Time index= ,Total clock time passed(s)"<<std::endl;
  }
  nlayerTot=int(ceil( (double)(g.nX[2]-bp.Nzh)/(double)g.nZlayer));
  vox.AddLayer1();
  g.UpdateLaser(); // initiate first laser location
  while (!bcheck){
    // update temperature field
    TempF.tInd = int(round(g.time/TempF.DelT));
    TempF.AnalyticTempCurr(g.time,TempF.TempCurr,part.icellidLoc,Ntot);
    // update next step for voxels 
    vox.UpdateVoxels();
    //write out
    g.UpdateLaser();
    bcheck=g.indlayer>nlayerTot;
    if (g.inewlayerflg==1){vox.CleanLayer();}
    indOut = TempF.tInd % g.outint;
    if (indOut==0 || bcheck || (g.inewlayerflg==1 && g.outNL==0)){
      filinds.push_back(TempF.tInd);
      filtime.push_back(g.time);
      filout = filbaseOut+std::to_string(TempF.tInd);
      filout = filbaseOut+std::to_string(TempF.tInd);
      vox.WriteToHDF1(filout);
      MPI_Barrier(MPI_COMM_WORLD);
    } // (indOut==0 ...
    g.UpdateTime2(TempF.DelT);    
    if (g.inewlayerflg==1){vox.AddLayer1();}
    auto texec2 = std::chrono::high_resolution_clock::now();
    auto delTexec = std::chrono::duration_cast<std::chrono::seconds>( texec2 - texec1 ).count();
    if (part.myid==0){std::cout << TempF.tInd<<","<<delTexec<< std::endl;}
    if (part.myid==0){fplog << TempF.tInd<<","<<delTexec<<std::endl;}
    } // while
  MPI_Barrier(MPI_COMM_WORLD);
  MPI_Finalize();
  return 0;
}
