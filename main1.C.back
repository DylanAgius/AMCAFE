/*
This runs the cellular automata model using a given temperature
input (obtained from Moose runs) to simulate microstructure
evolution of AM builds (20190123)

*/


// include files here
#include "Grid.h"
#include "VoxelsCA.h"
#include "BasePlate.h"
#include "TempField.h"
#include "Partition.h"
#include "SampleOrientation.h"
#include "iostream"
#include "vector"
#include <math.h>
#include <chrono>
#include <thread>
#include <algorithm>
#include "mpi.h"

#include "fstream"

int main()
{
  /*-----------------------------------------------
    initialization step */
  MPI_Init(NULL,NULL);
  int nprocs,myid;
  MPI_Comm_size(MPI_COMM_WORLD,&nprocs);
  MPI_Comm_rank(MPI_COMM_WORLD,&myid);
  
  int NtM,cc1,nDim;
  std::vector<int> nXM,nX;
  std::vector<double> dX,dXM,LX;
  double tL,mL,c0,Gamma,dP,dL,dtM,muN,layerThickness,T0;
  std::string filbaseTemp,filbaseOut,filout,neighOrder;
  double mu = 2e11; //2e11;//5e9 // rate for baseplate voronoi;
  double heightBase = .1e-3;
  // schwalbach parameters
  int patternID;
  double beamVel,beamSpacing,beamPower,wEst,cP,rho,kappa,beamEta,rcut;
  std::vector<double> beamSTD,LxAll;
  // schwalbach parameters

  nXM = {20,20,20};
  nX = {20,20,20};
  nDim = nX.size();
  LX = {.002,.002,.002};
  dX.assign(nDim,0.0);
  dXM.assign(nDim,0.0);
  for (int j=0;j<nDim;++j){
    dX[j] = LX[j]/double(nX[j]);
    dXM[j] = LX[j]/double(nXM[j]);
  }
  NtM = 50;
  dtM = .05; // must set based on moose results
  tL = 1609; // K
  mL = -10.9; // (K / wt%)
  dL = 3e-9; // (m^2/s)
  Gamma = 1e-7;  // (K m)
  muN = 9e-2; // rate for nucleation
  dP = .48;
  c0 = 4.85; // (wt %)
  filbaseTemp = "/Users/kteferra/Documents/research/projects/AMICME/codes/CA/tempData/tempField0.";
  neighOrder = "second"; // can equal "first", "second", "third"
  rho = 8000.0; // kg /m^3
  cP = 502.0; // J/kg-K)
  kappa = 18.0; // W/(m-K)
  layerThickness = 50e-5; //30e-6; // m
  Grid g(dX,nX,tL,mL,c0,Gamma,dP,dL,muN,rho,cP,kappa,layerThickness,neighOrder,nDim);
  Partition part(g,myid,nprocs);
  part.PartitionGraph();
  BasePlate bp(g,heightBase,mu, part);
  TempField TempF(g,part,bp);
  // initialize appropriate temperature model
  //TempF.InitializeMoose(filbaseTemp,NtM,dtM,nXM,dXM);
  beamVel = 70e-3; // m/s
  beamSTD = {20e-5,20e-5,50e-5}; //  {20e-6,20e-6,20e-6}; // m
  beamPower = 400; //300; // W
  beamEta = 1.0;
  wEst  = pow(8*beamPower/(exp(1.0)*M_PI*rho*cP*(tL-298.0)*beamVel),.5); // see EQ (1) in schwalbach
  beamSpacing = 4.0/3.0*beamSTD[1]; //wEst*.8;
  patternID = 0;
  LxAll = {.002,.002,.002}; //{.01,.01,.01}; // domain of entire piece, used for laser pattern (m)
  T0 = 300.0; // initial temperature in (K)
  TempF.InitializeSchwalbach(patternID,beamSTD,beamSpacing,beamVel,beamPower,beamEta,LxAll,T0);
  TempF.SchwalbachTempCurr();
  TempF.SchwalbachDDtTemp();
  //TempF.ReadCSVMoose2();
  //TempF.Test2();
  //TempF.ComputeDDtTemp();
    
  
  VoxelsCA vox(g,TempF, part);
  vox.InitializeVoxels(bp);
  //vox.InitializeTest1();
  /*
  if (part.myid==0){
    std::cout << bp.Ngrain << std::endl;
    for (int j=0;j<bp.Ngrain;++j){std::cout <<bp.gNucleus[j] << ",";}
  }
  MPI_Barrier(MPI_COMM_WORLD);
  */
  /*-----------------------------------------------
    execute simulation */
  cc1=0;
  int outskip=20;
  std::vector<int> filinds;
  std::vector<double> filtime;
  int icheck = 1,ichecktmp,cc2=0;
  filbaseOut = "CA3D";
  while (icheck!=0){
    cc2+=1;
    if (cc2>1000){icheck=0;}
    icheck=!std::all_of(vox.vState.begin(),vox.vState.end(),[](int n){return n==3;});
    ichecktmp = icheck;
    MPI_Allreduce(&ichecktmp,&icheck,1,MPI_INT,MPI_SUM,MPI_COMM_WORLD);
    if (g.tInd % outskip ==0 || icheck ==0){ 
      filinds.push_back(g.tInd);
      filtime.push_back(g.time);
      filout = filbaseOut+std::to_string(g.tInd);
      vox.WriteToVTU1(filout);
      filout = filbaseOut+".csv";
      vox.WriteCSVData(filout);
      cc1+=1;
      if (cc1 % 20 || icheck==0){
	filout=filbaseOut;
	vox.WriteToPVD(filout,filinds,filtime);
      } // if (cc1
      MPI_Barrier(MPI_COMM_WORLD);
    }

    // update next step for voxels (time is updated in vox.ComputeExtents() )
    vox.UpdateVoxels();

    //vox.ComputeNucleation1();

    // update temperature field
    TempF.SchwalbachTempCurr();
    TempF.SchwalbachDDtTemp();
    /* This is for reading CSV file
    if (int(floor(g.time/TempF.dtM))!=TempF.indexM){
      TempF.ReadCSVMoose2();
      TempF.ComputeDDtTemp();
    }
    */
    } // while
  MPI_Barrier(MPI_COMM_WORLD);
  MPI_Finalize();
  return 0;
}
